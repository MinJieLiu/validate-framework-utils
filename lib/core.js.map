{"version":3,"sources":["../src/core.js"],"names":["field","id","name","value","result","executedAsyncFunction","error","rules","split","isRequired","some","rule","index","ruleLength","length","parts","exec","method","param","jumpRule","indexOf","currentMethod","currentResult","apply","then","seqText","messages","message","replace"],"mappings":";;;;;;;;AAAA;;;;AAEA;;;;;;uDAKe,iBAAgBA,KAAhB;AAAA;AAAA;AAAA;AAAA;AAAA;AACLC,cADK,GACeD,KADf,CACLC,EADK,EACDC,IADC,GACeF,KADf,CACDE,IADC,EACKC,KADL,GACeH,KADf,CACKG,KADL;AAEb;;AACIC,kBAHS,GAGA,IAHA;AAIb;;AACIC,iCALS,GAKe,KALf;AAMb;;AACMC,iBAPO,GAOC;AACZL,oBADY;AAEZC,wBAFY;AAGZC;AAHY,aAPD;AAaPI,iBAbO,GAaCP,MAAMO,KAAN,CAAYC,KAAZ,CAAkB,WAAlB,CAbD;AAePC,sBAfO,GAeMF,MAAMG,IAAN,CAAW;AAAA,qBAAQC,SAAS,UAAjB;AAAA,aAAX,CAfN;AAiBJC,iBAjBI,GAiBI,CAjBJ,EAiBOC,UAjBP,GAiBoBN,MAAMO,MAjB1B;;AAAA;AAAA,kBAiBkCF,QAAQC,UAjB1C;AAAA;AAAA;AAAA;;AAkBLF,gBAlBK,GAkBEJ,MAAMK,KAAN,CAlBF;AAmBX;;AAnBW,gBAoBNR,MApBM;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAwBX;AACMW,iBAzBK,GAyBG,kBAAkBC,IAAlB,CAAuBL,IAAvB,CAzBH;AA0BPM,kBA1BO,GA0BEN,IA1BF;AA2BPO,iBA3BO,GA2BC,EA3BD;;AA6BX;;AACA,gBAAIH,KAAJ,EAAW;AACTE,uBAASF,MAAM,CAAN,CAAT;AACAG,sBAAQH,MAAM,CAAN,CAAR;AACD;;AAED;AACMI,oBApCK,GAoCM,CAACV,UAAD,IAAe,mBAAQN,KAAR,CAAf,IAAiCc,OAAOG,OAAP,CAAe,UAAf,MAA+B,CApCtE;;AAsCX;;AACMC,yBAvCK,GAuCW,KAAKJ,MAAL,CAvCX;AAwCX;;AAxCW,kBAyCP,OAAOI,aAAP,KAAyB,UAAzB,IAAuC,CAACF,QAzCjC;AAAA;AAAA;AAAA;;AA0CT;AACMG,yBA3CG,GA2CaD,cAAcE,KAAd,CAAoB,IAApB,EAA0B,CAACvB,KAAD,EAAQkB,KAAR,CAA1B,CA3Cb;AA4CT;AACA;;AA7CS,kBA8CL,QAAOI,aAAP,yCAAOA,aAAP,OAAyB,QAAzB,IAAqCA,cAAcE,IA9C9C;AAAA;AAAA;AAAA;;AA+CPnB,oCAAwB,IAAxB;AACA;AAhDO;AAAA,mBAiDQiB,aAjDR;;AAAA;AAiDPlB,kBAjDO;AAAA;AAAA;;AAAA;AAmDPA,qBAASkB,aAAT;;AAnDO;;AAuDX;AACA,gBAAI,CAAClB,MAAL,EAAa;AACX;AACAE,oBAAMK,IAAN,GAAaM,MAAb;;AAEA;AACMQ,qBALK,GAKKzB,MAAM0B,QAAN,GAAiB1B,MAAM0B,QAAN,CAAelB,KAAf,CAAqB,WAArB,EAAkCI,KAAlC,CAAjB,GAA4D,EALjE;;AAMXN,oBAAMqB,OAAN,GAAgBF,UACZA,QAAQG,OAAR,CAAgB,kBAAhB,EAAoCzB,KAApC,EAA2CyB,OAA3C,CAAmD,kBAAnD,EAAuEV,KAAvE,CADY,GAEZO,OAFJ;AAGD;;AAjEU;AAiBsDb,qBAAS,CAjB/D;AAAA;AAAA;;AAAA;AAAA,6CAoEN;AACLR,4BADK;AAELE,0BAFK;AAGLD;AAHK,aApEM;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G","file":"core.js","sourcesContent":["import { isEmpty } from './util';\n\n/**\n * 通过 field 验证\n * @param  {Object} field 验证信息域\n * @return {Object} 包含结果、错误信息\n */\nexport default async function (field) {\n  const { id, name, value } = field;\n  // 成功标识\n  let result = true;\n  // 是否执行过异步方法\n  let executedAsyncFunction = false;\n  // 错误信息域\n  const error = {\n    id,\n    name,\n    value,\n  };\n\n  const rules = field.rules.split(/\\s*\\|\\s*/g);\n\n  const isRequired = rules.some(rule => rule === 'required');\n\n  for (let index = 0, ruleLength = rules.length; index < ruleLength; index += 1) {\n    const rule = rules[index];\n    // 标识不通过，则不继续验证该规则\n    if (!result) {\n      break;\n    }\n\n    // 转换：maxLength(12) => ['maxLength', 12]\n    const parts = /^(.+?)\\((.+)\\)$/.exec(rule);\n    let method = rule;\n    let param = '';\n\n    // 解析带参数的验证如 maxLength(12)\n    if (parts) {\n      method = parts[1];\n      param = parts[2];\n    }\n\n    // 整体规则中没有 required，并且该值为空，并且不以 required 开头，则不验证\n    const jumpRule = !isRequired && isEmpty(value) && method.indexOf('required') !== 0;\n\n    // 当前方法\n    const currentMethod = this[method];\n    // 匹配验证\n    if (typeof currentMethod === 'function' && !jumpRule) {\n      // Validate\n      const currentResult = currentMethod.apply(this, [field, param]);\n      // 异步方法\n      // babel 中无法使用该判断: Object.getPrototypeOf(currentMethod).constructor.name === 'AsyncFunction'\n      if (typeof currentResult === 'object' && currentResult.then) {\n        executedAsyncFunction = true;\n        // eslint-disable-next-line no-await-in-loop\n        result = await currentResult;\n      } else {\n        result = currentResult;\n      }\n    }\n\n    // 验证不通过，则解析错误信息\n    if (!result) {\n      // 当前验证不通过的规则\n      error.rule = method;\n\n      // 替换 {{value}} 和 {{param}} 中参数\n      const seqText = field.messages ? field.messages.split(/\\s*\\|\\s*/g)[index] : '';\n      error.message = seqText\n        ? seqText.replace(/{{\\s*value\\s*}}/g, value).replace(/{{\\s*param\\s*}}/g, param)\n        : seqText;\n    }\n  }\n\n  return {\n    result,\n    error,\n    executedAsyncFunction,\n  };\n}\n"]}