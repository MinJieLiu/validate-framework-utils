{"version":3,"sources":["../src/core.js"],"names":["field","id","name","rules","split","isRequired","some","rule","value","result","promisedResultMap","error","index","ruleLength","parts","exec","method","param","getErrorMessage","seqText","messages","message","replace","jumpRule","indexOf","currentMethod","currentResult","apply","then","resolvedResult","Object","assign","length"],"mappings":";;;;;;;;AAEA;;;;;;;kBAKe,UAAUA,KAAV,EAAiB;AAAA;;AAC9B;AAD8B,MAEtBC,EAFsB,GAETD,KAFS,CAEtBC,EAFsB;AAAA,MAElBC,IAFkB,GAETF,KAFS,CAElBE,IAFkB;;AAG9B,MAAMC,QAAQH,MAAMG,KAAN,CAAYC,KAAZ,CAAkB,WAAlB,CAAd;AACA,MAAMC,aAAaF,MAAMG,IAAN,CAAW;AAAA,WAAQC,SAAS,UAAjB;AAAA,GAAX,CAAnB;;AAEA,SAAO,UAACC,KAAD,EAAW;AAChB;AACA,QAAIC,SAAS,IAAb;AACA;AACA,QAAIC,0BAAJ;AACA;AACA,QAAMC,QAAQ;AACZV,YADY;AAEZC,gBAFY;AAGZM;AAHY,KAAd;;AAMAR,UAAMQ,KAAN,GAAcA,KAAd,CAZgB,CAYK;;AAZL,+BAcPI,KAdO,EAcIC,UAdJ;AAed,UAAMN,OAAOJ,MAAMS,KAAN,CAAb;AACA;AACA,UAAI,CAACH,MAAL,EAAa;AACX;AACD;;AAED;AACA,UAAMK,QAAQ,kBAAkBC,IAAlB,CAAuBR,IAAvB,CAAd;AACA,UAAIS,SAAST,IAAb;AACA,UAAIU,cAAJ;;AAEA,UAAMC,kBAAkB,SAAlBA,eAAkB,GAAM;AAC5B,YAAMC,UAAUnB,MAAMoB,QAAN,GAAiBpB,MAAMoB,QAAN,CAAehB,KAAf,CAAqB,WAArB,EAAkCQ,KAAlC,CAAjB,GAA4D,EAA5E;AACA,eAAO;AACLL,gBAAMS,MADD;AAELK,mBAASF,QAAQ;AAAR,YACLA,QAAQG,OAAR,CAAgB,kBAAhB,EAAoCd,KAApC,EAA2Cc,OAA3C,CAAmD,kBAAnD,EAAuEL,KAAvE,CADK,GAELE;AAJC,SAAP;AAMD,OARD;;AAUA;AACA,UAAIL,KAAJ,EAAW;AACTE,iBAASF,MAAM,CAAN,CAAT;AACAG,gBAAQH,MAAM,CAAN,CAAR;AACD;;AAED;AACA,UAAMS,WAAW,CAAClB,UAAD,IAAe,mBAAQG,KAAR,CAAf,IAAiCQ,OAAOQ,OAAP,CAAe,UAAf,MAA+B,CAAjF;;AAEA;AACA,UAAMC,gBAAgB,MAAKT,MAAL,CAAtB;AACA;AACA,UAAI,OAAOS,aAAP,KAAyB,UAAzB,IAAuC,CAACF,QAA5C,EAAsD;AACpD;AACA,YAAMG,gBAAgBD,cAAcE,KAAd,QAA0B,CAAC3B,KAAD,EAAQiB,KAAR,CAA1B,CAAtB;;AAEA,YAAI,qBAAUS,aAAV,CAAJ,EAA8B;AAC5BhB,8BAAoBgB,cAAcE,IAAd,CAAmB;AAAA,mBAAmB;AACxDnB,sBAAQoB,cADgD;AAExDlB,kCACKA,KADL,EAEK,CAACkB,cAAD,IAAmBX,iBAFxB;AAFwD,aAAnB;AAAA,WAAnB,CAApB;AAOD;;AAED,YAAI,CAACQ,aAAL,EAAoB;AAClBjB,mBAAS,KAAT;AACD;AACF;;AAED;AACA,UAAI,CAACA,MAAL,EAAa;AACXqB,eAAOC,MAAP,CAAcpB,KAAd,EAAqBO,iBAArB;AACD;AAtEa;;AAchB,SAAK,IAAIN,QAAQ,CAAZ,EAAeC,aAAaV,MAAM6B,MAAvC,EAA+CpB,QAAQC,UAAvD,EAAmED,SAAS,CAA5E,EAA+E;AAAA,uBAAtEA,KAAsE,EAA3DC,UAA2D;;AAAA,4BAI3E;AAqDH;;AAED,QAAIH,iBAAJ,EAAuB;AACrB,aAAOA,iBAAP;AACD;;AAED,WAAO;AACLD,oBADK;AAELE;AAFK,KAAP;AAID,GAjFD;AAkFD,C;;AA/FD","file":"core.js","sourcesContent":["import { isEmpty, isPromise } from './util';\n\n/**\n * 通过 field 验证\n * @param  {Object} field 验证信息域\n * @return {Function} 可通过 value 验证：包含结果、错误信息\n */\nexport default function (field) {\n  // Variables\n  const { id, name } = field;\n  const rules = field.rules.split(/\\s*\\|\\s*/g);\n  const isRequired = rules.some(rule => rule === 'required');\n\n  return (value) => {\n    // 成功标识\n    let result = true;\n    // 包含 Promise 的返回值\n    let promisedResultMap;\n    // 错误信息域\n    const error = {\n      id,\n      name,\n      value,\n    };\n\n    field.value = value; // eslint-disable-line no-param-reassign\n\n    for (let index = 0, ruleLength = rules.length; index < ruleLength; index += 1) {\n      const rule = rules[index];\n      // 标识不通过，则不继续验证该规则\n      if (!result) {\n        break;\n      }\n\n      // 转换：maxLength(12) => ['maxLength', 12]\n      const parts = /^(.+?)\\((.+)\\)$/.exec(rule);\n      let method = rule;\n      let param;\n\n      const getErrorMessage = () => {\n        const seqText = field.messages ? field.messages.split(/\\s*\\|\\s*/g)[index] : '';\n        return {\n          rule: method,\n          message: seqText // 替换 {{value}} 和 {{param}} 中参数\n            ? seqText.replace(/{{\\s*value\\s*}}/g, value).replace(/{{\\s*param\\s*}}/g, param)\n            : seqText,\n        };\n      };\n\n      // 解析带参数的验证如 maxLength(12)\n      if (parts) {\n        method = parts[1];\n        param = parts[2];\n      }\n\n      // 整体规则中没有 required，并且该值为空，并且不以 required 开头，则不验证\n      const jumpRule = !isRequired && isEmpty(value) && method.indexOf('required') !== 0;\n\n      // 当前方法\n      const currentMethod = this[method];\n      // 匹配验证\n      if (typeof currentMethod === 'function' && !jumpRule) {\n        // Validate\n        const currentResult = currentMethod.apply(this, [field, param]);\n\n        if (isPromise(currentResult)) {\n          promisedResultMap = currentResult.then(resolvedResult => ({\n            result: resolvedResult,\n            error: {\n              ...error,\n              ...!resolvedResult && getErrorMessage(),\n            },\n          }));\n        }\n\n        if (!currentResult) {\n          result = false;\n        }\n      }\n\n      // 验证不通过，则解析错误信息\n      if (!result) {\n        Object.assign(error, getErrorMessage());\n      }\n    }\n\n    if (promisedResultMap) {\n      return promisedResultMap;\n    }\n\n    return {\n      result,\n      error,\n    };\n  };\n}\n"]}